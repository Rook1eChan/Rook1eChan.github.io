<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><link href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;700&family=JetBrains+Mono&display=swap" rel=stylesheet><meta name=robots content="index, follow"><title>DAPR A Benchmark on Document-Aware Passage Retrieval | Chan's Blog</title><meta name=keywords content><meta name=description content="1.Motivation
现有的神经检索（neural retrieval）的方法主要集中在短文本排序，在长篇文章中做检索效果并不好（由于自注意力机制token数量的限制；或者返回的文档过长，不便于用户使用）。另外，作者发现在先进检索器的检索错误中，半数错误与缺少上下文有关。
比如：在A剧场中演出过的演员有哪些？如果只检索关键字“A剧场”，可能找不到答案，需要结合上下文找到“……在这里演出过……”的内容才是真正答案。
因此，作者针对上下文强关联的任务建立了一个数据集，使用两类方法（hybrid retrieval with BM25、 contextualized passage representations）进行实验，并详细解释了实验结果。

2.Related work

Document Question Answering（DocQA）：要求模型回答关于输入文档的问题，通常假设文档在提问前就已给出。本文提出的(Document-Awarepassage Retrieval, DAPR)与DocQA类似，区别在于DAPR希望用户提问时不知道目标文档，由模型来寻找目标文档。
Long-document retrieval（长文档检索）：对于长文档检索有一些简单的方法：将文档中段落相关性的最大值作为文档的相关性（MaxP）；仅编码文档中的第一个段落（FirstP）……与DAPR相比，所有这些先前的工作都没有研究如何在考虑文档上下文的情况下检索段落。
Hybrid retrieval（混合检索）：对于一个查询使用多个检索系统（常常是BM25+神经检索）

rank fusion（排名融合）——通过凸组合、互逆排名等方法将不同检索系统的个体排名合并为一个。
hierarchical retrieval（层次检索）——首先检索文档，然后从这些文档中检索段落。只适用于段落本身足以对查询做出响应的情况。
本文探讨了段落排名和文档排名结合的有效性。


Relation to pre-training tasks（和预训练任务的关系）：有的研究在预训练中加入上下文。但推理时仍然只关注独立的段落。
补充：

NQ：谷歌的一个问答数据集
NDCG：评价检索序列的相关性和位置
共指信息：描述文本中不同表达式指向同一实体或概念的语言现象，如*“玛丽打开了门，她随后拿起包。”* → “她”与“玛丽”共指同一人。
共指消解（Coreference Resolution）：自动识别文本中所有指向同一实体的表达式并分组。




3.Method
DAPR任务要求系统提取+排序。给出段落集合$C$，文档集合$D$，对于查询集合$q \in Q$，检索系统$s$应该提取出最好的$K$个段落集合$R$。
3.1NQ-Hard
对SOTA的检索器（DRAGON+,SPLADEv2, and ColBERTv2)使用NQ数据集，发现一半的错误来自于不了解上下文。将这些数据命名为NQ-hard，并分为4类：

共指消解（CR）：关键的共指信息需要通过特定文档上下文来解析；
主要主题（MT）：只有了解文档的背景主题（通常是标题），才能回答查询；
多跳推理（MHR）：连接查询和查询相关段落中的实体的推理路径包括文档上下文中的其他节点；
缩写（AC）：在相关段落（或查询）中出现一个缩写，该缩写对应于查询（或相关段落）中的全称，文档上下文解释了这种映射；



3.2Datasets
MS MARCO、Natural Questions、MIRACL、Genomics 和 ConditionalQA（具体处理方式见附录A）有语料库的直接用，没有的把黄金段落文本收集起来当语料库。（也是很神奇）

3.3Evaluation
使用nDCG@10和recall@100做指标。
将binary/3-scale转换为0-1/0-1-2，然后使用pytrec_eval计算指标。
考虑到现实世界中的检索系统多用于零样本、跨领域的情景，本文进行了一项测试：在MS MARCO训练集训练，然后在MS MARCO测试集测试，作为域内评估；在其它四个数据集上测试，作为域外评估。

4.Experiments
4.1基础检索器

BM25（使用PySerini的默认配置）
neural retrievers：DRAGON+、SPLADEv2、ColBERTv2（在MS MARCO上训练）


4.2两种将上下文引入神经检索器的方法
4.2.1加入BM25的混合检索
（1）Rank fusion融合检索"><meta name=author content><link rel=canonical href=https://Rook1eChan.github.io/posts/dapr-a-benchmark-on-document-aware-passage-retrieval/><link crossorigin=anonymous href=/assets/css/stylesheet.7f5d6d31e606c3178e091cb55298baed021a501ad4c10fd725847674935b1b15.css integrity="sha256-f11tMeYGwxeOCRy1Upi67QIaUBrUwQ/XJYR2dJNbGxU=" rel="preload stylesheet" as=style><link rel=icon href=https://Rook1eChan.github.io/apple-touch-icon.png><link rel=icon type=image/png sizes=16x16 href=https://Rook1eChan.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://Rook1eChan.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://Rook1eChan.github.io/apple-touch-icon.png><link rel=mask-icon href=https://Rook1eChan.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://Rook1eChan.github.io/posts/dapr-a-benchmark-on-document-aware-passage-retrieval/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://Rook1eChan.github.io/posts/dapr-a-benchmark-on-document-aware-passage-retrieval/"><meta property="og:site_name" content="Chan's Blog"><meta property="og:title" content="DAPR A Benchmark on Document-Aware Passage Retrieval"><meta property="og:description" content="1.Motivation 现有的神经检索（neural retrieval）的方法主要集中在短文本排序，在长篇文章中做检索效果并不好（由于自注意力机制token数量的限制；或者返回的文档过长，不便于用户使用）。另外，作者发现在先进检索器的检索错误中，半数错误与缺少上下文有关。
比如：在A剧场中演出过的演员有哪些？如果只检索关键字“A剧场”，可能找不到答案，需要结合上下文找到“……在这里演出过……”的内容才是真正答案。
因此，作者针对上下文强关联的任务建立了一个数据集，使用两类方法（hybrid retrieval with BM25、 contextualized passage representations）进行实验，并详细解释了实验结果。
2.Related work Document Question Answering（DocQA）：要求模型回答关于输入文档的问题，通常假设文档在提问前就已给出。本文提出的(Document-Awarepassage Retrieval, DAPR)与DocQA类似，区别在于DAPR希望用户提问时不知道目标文档，由模型来寻找目标文档。 Long-document retrieval（长文档检索）：对于长文档检索有一些简单的方法：将文档中段落相关性的最大值作为文档的相关性（MaxP）；仅编码文档中的第一个段落（FirstP）……与DAPR相比，所有这些先前的工作都没有研究如何在考虑文档上下文的情况下检索段落。 Hybrid retrieval（混合检索）：对于一个查询使用多个检索系统（常常是BM25+神经检索） rank fusion（排名融合）——通过凸组合、互逆排名等方法将不同检索系统的个体排名合并为一个。 hierarchical retrieval（层次检索）——首先检索文档，然后从这些文档中检索段落。只适用于段落本身足以对查询做出响应的情况。 本文探讨了段落排名和文档排名结合的有效性。 Relation to pre-training tasks（和预训练任务的关系）：有的研究在预训练中加入上下文。但推理时仍然只关注独立的段落。 补充： NQ：谷歌的一个问答数据集 NDCG：评价检索序列的相关性和位置 共指信息：描述文本中不同表达式指向同一实体或概念的语言现象，如*“玛丽打开了门，她随后拿起包。”* → “她”与“玛丽”共指同一人。 共指消解（Coreference Resolution）：自动识别文本中所有指向同一实体的表达式并分组。 3.Method DAPR任务要求系统提取+排序。给出段落集合$C$，文档集合$D$，对于查询集合$q \in Q$，检索系统$s$应该提取出最好的$K$个段落集合$R$。
3.1NQ-Hard 对SOTA的检索器（DRAGON+,SPLADEv2, and ColBERTv2)使用NQ数据集，发现一半的错误来自于不了解上下文。将这些数据命名为NQ-hard，并分为4类：
共指消解（CR）：关键的共指信息需要通过特定文档上下文来解析； 主要主题（MT）：只有了解文档的背景主题（通常是标题），才能回答查询； 多跳推理（MHR）：连接查询和查询相关段落中的实体的推理路径包括文档上下文中的其他节点； 缩写（AC）：在相关段落（或查询）中出现一个缩写，该缩写对应于查询（或相关段落）中的全称，文档上下文解释了这种映射； 3.2Datasets MS MARCO、Natural Questions、MIRACL、Genomics 和 ConditionalQA（具体处理方式见附录A）有语料库的直接用，没有的把黄金段落文本收集起来当语料库。（也是很神奇）
3.3Evaluation 使用nDCG@10和recall@100做指标。
将binary/3-scale转换为0-1/0-1-2，然后使用pytrec_eval计算指标。
考虑到现实世界中的检索系统多用于零样本、跨领域的情景，本文进行了一项测试：在MS MARCO训练集训练，然后在MS MARCO测试集测试，作为域内评估；在其它四个数据集上测试，作为域外评估。
4.Experiments 4.1基础检索器 BM25（使用PySerini的默认配置） neural retrievers：DRAGON+、SPLADEv2、ColBERTv2（在MS MARCO上训练） 4.2两种将上下文引入神经检索器的方法 4.2.1加入BM25的混合检索 （1）Rank fusion融合检索"><meta property="og:locale" content="zh-CN"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-05-02T16:41:03+08:00"><meta property="article:modified_time" content="2025-05-02T16:41:03+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="DAPR A Benchmark on Document-Aware Passage Retrieval"><meta name=twitter:description content="1.Motivation
现有的神经检索（neural retrieval）的方法主要集中在短文本排序，在长篇文章中做检索效果并不好（由于自注意力机制token数量的限制；或者返回的文档过长，不便于用户使用）。另外，作者发现在先进检索器的检索错误中，半数错误与缺少上下文有关。
比如：在A剧场中演出过的演员有哪些？如果只检索关键字“A剧场”，可能找不到答案，需要结合上下文找到“……在这里演出过……”的内容才是真正答案。
因此，作者针对上下文强关联的任务建立了一个数据集，使用两类方法（hybrid retrieval with BM25、 contextualized passage representations）进行实验，并详细解释了实验结果。

2.Related work

Document Question Answering（DocQA）：要求模型回答关于输入文档的问题，通常假设文档在提问前就已给出。本文提出的(Document-Awarepassage Retrieval, DAPR)与DocQA类似，区别在于DAPR希望用户提问时不知道目标文档，由模型来寻找目标文档。
Long-document retrieval（长文档检索）：对于长文档检索有一些简单的方法：将文档中段落相关性的最大值作为文档的相关性（MaxP）；仅编码文档中的第一个段落（FirstP）……与DAPR相比，所有这些先前的工作都没有研究如何在考虑文档上下文的情况下检索段落。
Hybrid retrieval（混合检索）：对于一个查询使用多个检索系统（常常是BM25+神经检索）

rank fusion（排名融合）——通过凸组合、互逆排名等方法将不同检索系统的个体排名合并为一个。
hierarchical retrieval（层次检索）——首先检索文档，然后从这些文档中检索段落。只适用于段落本身足以对查询做出响应的情况。
本文探讨了段落排名和文档排名结合的有效性。


Relation to pre-training tasks（和预训练任务的关系）：有的研究在预训练中加入上下文。但推理时仍然只关注独立的段落。
补充：

NQ：谷歌的一个问答数据集
NDCG：评价检索序列的相关性和位置
共指信息：描述文本中不同表达式指向同一实体或概念的语言现象，如*“玛丽打开了门，她随后拿起包。”* → “她”与“玛丽”共指同一人。
共指消解（Coreference Resolution）：自动识别文本中所有指向同一实体的表达式并分组。




3.Method
DAPR任务要求系统提取+排序。给出段落集合$C$，文档集合$D$，对于查询集合$q \in Q$，检索系统$s$应该提取出最好的$K$个段落集合$R$。
3.1NQ-Hard
对SOTA的检索器（DRAGON+,SPLADEv2, and ColBERTv2)使用NQ数据集，发现一半的错误来自于不了解上下文。将这些数据命名为NQ-hard，并分为4类：

共指消解（CR）：关键的共指信息需要通过特定文档上下文来解析；
主要主题（MT）：只有了解文档的背景主题（通常是标题），才能回答查询；
多跳推理（MHR）：连接查询和查询相关段落中的实体的推理路径包括文档上下文中的其他节点；
缩写（AC）：在相关段落（或查询）中出现一个缩写，该缩写对应于查询（或相关段落）中的全称，文档上下文解释了这种映射；



3.2Datasets
MS MARCO、Natural Questions、MIRACL、Genomics 和 ConditionalQA（具体处理方式见附录A）有语料库的直接用，没有的把黄金段落文本收集起来当语料库。（也是很神奇）

3.3Evaluation
使用nDCG@10和recall@100做指标。
将binary/3-scale转换为0-1/0-1-2，然后使用pytrec_eval计算指标。
考虑到现实世界中的检索系统多用于零样本、跨领域的情景，本文进行了一项测试：在MS MARCO训练集训练，然后在MS MARCO测试集测试，作为域内评估；在其它四个数据集上测试，作为域外评估。

4.Experiments
4.1基础检索器

BM25（使用PySerini的默认配置）
neural retrievers：DRAGON+、SPLADEv2、ColBERTv2（在MS MARCO上训练）


4.2两种将上下文引入神经检索器的方法
4.2.1加入BM25的混合检索
（1）Rank fusion融合检索"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://Rook1eChan.github.io/posts/"},{"@type":"ListItem","position":2,"name":"DAPR A Benchmark on Document-Aware Passage Retrieval","item":"https://Rook1eChan.github.io/posts/dapr-a-benchmark-on-document-aware-passage-retrieval/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"DAPR A Benchmark on Document-Aware Passage Retrieval","name":"DAPR A Benchmark on Document-Aware Passage Retrieval","description":"1.Motivation 现有的神经检索（neural retrieval）的方法主要集中在短文本排序，在长篇文章中做检索效果并不好（由于自注意力机制token数量的限制；或者返回的文档过长，不便于用户使用）。另外，作者发现在先进检索器的检索错误中，半数错误与缺少上下文有关。\n比如：在A剧场中演出过的演员有哪些？如果只检索关键字“A剧场”，可能找不到答案，需要结合上下文找到“……在这里演出过……”的内容才是真正答案。\n因此，作者针对上下文强关联的任务建立了一个数据集，使用两类方法（hybrid retrieval with BM25、 contextualized passage representations）进行实验，并详细解释了实验结果。\n2.Related work Document Question Answering（DocQA）：要求模型回答关于输入文档的问题，通常假设文档在提问前就已给出。本文提出的(Document-Awarepassage Retrieval, DAPR)与DocQA类似，区别在于DAPR希望用户提问时不知道目标文档，由模型来寻找目标文档。 Long-document retrieval（长文档检索）：对于长文档检索有一些简单的方法：将文档中段落相关性的最大值作为文档的相关性（MaxP）；仅编码文档中的第一个段落（FirstP）……与DAPR相比，所有这些先前的工作都没有研究如何在考虑文档上下文的情况下检索段落。 Hybrid retrieval（混合检索）：对于一个查询使用多个检索系统（常常是BM25+神经检索） rank fusion（排名融合）——通过凸组合、互逆排名等方法将不同检索系统的个体排名合并为一个。 hierarchical retrieval（层次检索）——首先检索文档，然后从这些文档中检索段落。只适用于段落本身足以对查询做出响应的情况。 本文探讨了段落排名和文档排名结合的有效性。 Relation to pre-training tasks（和预训练任务的关系）：有的研究在预训练中加入上下文。但推理时仍然只关注独立的段落。 补充： NQ：谷歌的一个问答数据集 NDCG：评价检索序列的相关性和位置 共指信息：描述文本中不同表达式指向同一实体或概念的语言现象，如*“玛丽打开了门，她随后拿起包。”* → “她”与“玛丽”共指同一人。 共指消解（Coreference Resolution）：自动识别文本中所有指向同一实体的表达式并分组。 3.Method DAPR任务要求系统提取+排序。给出段落集合$C$，文档集合$D$，对于查询集合$q \\in Q$，检索系统$s$应该提取出最好的$K$个段落集合$R$。\n3.1NQ-Hard 对SOTA的检索器（DRAGON+,SPLADEv2, and ColBERTv2)使用NQ数据集，发现一半的错误来自于不了解上下文。将这些数据命名为NQ-hard，并分为4类：\n共指消解（CR）：关键的共指信息需要通过特定文档上下文来解析； 主要主题（MT）：只有了解文档的背景主题（通常是标题），才能回答查询； 多跳推理（MHR）：连接查询和查询相关段落中的实体的推理路径包括文档上下文中的其他节点； 缩写（AC）：在相关段落（或查询）中出现一个缩写，该缩写对应于查询（或相关段落）中的全称，文档上下文解释了这种映射； 3.2Datasets MS MARCO、Natural Questions、MIRACL、Genomics 和 ConditionalQA（具体处理方式见附录A）有语料库的直接用，没有的把黄金段落文本收集起来当语料库。（也是很神奇）\n3.3Evaluation 使用nDCG@10和recall@100做指标。\n将binary/3-scale转换为0-1/0-1-2，然后使用pytrec_eval计算指标。\n考虑到现实世界中的检索系统多用于零样本、跨领域的情景，本文进行了一项测试：在MS MARCO训练集训练，然后在MS MARCO测试集测试，作为域内评估；在其它四个数据集上测试，作为域外评估。\n4.Experiments 4.1基础检索器 BM25（使用PySerini的默认配置） neural retrievers：DRAGON+、SPLADEv2、ColBERTv2（在MS MARCO上训练） 4.2两种将上下文引入神经检索器的方法 4.2.1加入BM25的混合检索 （1）Rank fusion融合检索\n","keywords":[],"articleBody":"1.Motivation 现有的神经检索（neural retrieval）的方法主要集中在短文本排序，在长篇文章中做检索效果并不好（由于自注意力机制token数量的限制；或者返回的文档过长，不便于用户使用）。另外，作者发现在先进检索器的检索错误中，半数错误与缺少上下文有关。\n比如：在A剧场中演出过的演员有哪些？如果只检索关键字“A剧场”，可能找不到答案，需要结合上下文找到“……在这里演出过……”的内容才是真正答案。\n因此，作者针对上下文强关联的任务建立了一个数据集，使用两类方法（hybrid retrieval with BM25、 contextualized passage representations）进行实验，并详细解释了实验结果。\n2.Related work Document Question Answering（DocQA）：要求模型回答关于输入文档的问题，通常假设文档在提问前就已给出。本文提出的(Document-Awarepassage Retrieval, DAPR)与DocQA类似，区别在于DAPR希望用户提问时不知道目标文档，由模型来寻找目标文档。 Long-document retrieval（长文档检索）：对于长文档检索有一些简单的方法：将文档中段落相关性的最大值作为文档的相关性（MaxP）；仅编码文档中的第一个段落（FirstP）……与DAPR相比，所有这些先前的工作都没有研究如何在考虑文档上下文的情况下检索段落。 Hybrid retrieval（混合检索）：对于一个查询使用多个检索系统（常常是BM25+神经检索） rank fusion（排名融合）——通过凸组合、互逆排名等方法将不同检索系统的个体排名合并为一个。 hierarchical retrieval（层次检索）——首先检索文档，然后从这些文档中检索段落。只适用于段落本身足以对查询做出响应的情况。 本文探讨了段落排名和文档排名结合的有效性。 Relation to pre-training tasks（和预训练任务的关系）：有的研究在预训练中加入上下文。但推理时仍然只关注独立的段落。 补充： NQ：谷歌的一个问答数据集 NDCG：评价检索序列的相关性和位置 共指信息：描述文本中不同表达式指向同一实体或概念的语言现象，如*“玛丽打开了门，她随后拿起包。”* → “她”与“玛丽”共指同一人。 共指消解（Coreference Resolution）：自动识别文本中所有指向同一实体的表达式并分组。 3.Method DAPR任务要求系统提取+排序。给出段落集合$C$，文档集合$D$，对于查询集合$q \\in Q$，检索系统$s$应该提取出最好的$K$个段落集合$R$。\n3.1NQ-Hard 对SOTA的检索器（DRAGON+,SPLADEv2, and ColBERTv2)使用NQ数据集，发现一半的错误来自于不了解上下文。将这些数据命名为NQ-hard，并分为4类：\n共指消解（CR）：关键的共指信息需要通过特定文档上下文来解析； 主要主题（MT）：只有了解文档的背景主题（通常是标题），才能回答查询； 多跳推理（MHR）：连接查询和查询相关段落中的实体的推理路径包括文档上下文中的其他节点； 缩写（AC）：在相关段落（或查询）中出现一个缩写，该缩写对应于查询（或相关段落）中的全称，文档上下文解释了这种映射； 3.2Datasets MS MARCO、Natural Questions、MIRACL、Genomics 和 ConditionalQA（具体处理方式见附录A）有语料库的直接用，没有的把黄金段落文本收集起来当语料库。（也是很神奇）\n3.3Evaluation 使用nDCG@10和recall@100做指标。\n将binary/3-scale转换为0-1/0-1-2，然后使用pytrec_eval计算指标。\n考虑到现实世界中的检索系统多用于零样本、跨领域的情景，本文进行了一项测试：在MS MARCO训练集训练，然后在MS MARCO测试集测试，作为域内评估；在其它四个数据集上测试，作为域外评估。\n4.Experiments 4.1基础检索器 BM25（使用PySerini的默认配置） neural retrievers：DRAGON+、SPLADEv2、ColBERTv2（在MS MARCO上训练） 4.2两种将上下文引入神经检索器的方法 4.2.1加入BM25的混合检索 （1）Rank fusion融合检索\n由于神经网络适合于检测512tokens内的段落，而BM25无长度限制，所以使用BM25检索整个文档，而使用神经检索器检索段落。\n相关性分数为：\n$$s_{convex}(q,p,d)=\\alpha\\hat s_{BM25}(q,p) + (1-\\alpha)\\hat s_{nueral}(q,d)$$（公式有误）\n$\\hat s_{BM25},\\hat s_{nueral}$的分数都是归一化的。归一化公式为：\n$$\\hat{s}(q, c) = \\frac{s(q, c) - m_q}{M_q - m_q}$$​\n$s(q, c)$：检索器对查询(q)和候选文本(c)（段落或文档）的原始分数。 $m_q和M_q$：当前查询(q)的Top候选结果中分数的最小值和最大值。 若候选文本(c)在某一检索器的结果中缺失（未进入Top列表），则其分数视为0。 分数计算示例：\n输入数据:\n5篇文章，每篇2个段落： 文章D1：段落P1, P2 文章D2：段落P3, P4 文章D3：段落P5, P6 文章D4：段落P7, P8 文章D5：段落P9, P10 文档级检索结果 (topk=2)： 得分：D1=0.8, D2=0.6（其他文档得分低于这两个） 段落级检索结果 (topk=2)： 得分：P3=0.9, P5=0.7（其他段落得分低于这两个） 段落到文档映射： pid2did = { 'P1':'D1', 'P2':'D1', 'P3':'D2', 'P4':'D2', 'P5':'D3', 'P6':'D3', 'P7':'D4', 'P8':'D4', 'P9':'D5', 'P10':'D5' } 段落权重：假设passage_weight=0.4（文档权重自动为0.6） 计算过程:\n构建得分映射： did2score = {'D1':0.8, 'D2':0.6} # 文档级top2 pid2score = {'P3':0.9, 'P5':0.7} # 段落级top2 传播文档得分到段落： doc_pid2score = { 'P3': did2score['D2'], # P3属于D2 → 0.6 'P5': did2score['D3'] # 但D3不在did2score中(文档级只返回了D1,D2) } 实际结果只有{'P3':0.6}，因为D3不在文档级top2中\nM2C2融合（假设是线性加权）： 对P3： 文档得分：0.6 段落得分：0.9 融合得分 = 0.6*0.6 + 0.9*0.4 = 0.36 + 0.36 = 0.72 对P5： 文档得分：无 → 可能视为0或忽略 段落得分：0.7 如果忽略文档部分：0.7*0.4 = 0.28 最终融合结果： fused = {'P3':0.72, 'P5':0.28} （2）Hierarchical retrieval层次检索\n第一步先BM25检索文档，第二步神经检索搜索段落，并在第二步应用带有分数归一化的排名融合。\n4.2.2上下文化的段落表示 （1）**Prepending titles：**将文章标题放在每个段落的开头，并用特殊标记分割。可能会出现文档无标题或标题无意义。\n（2）**Prepending document keyphrases：**使用TopicRank算法（不知道在RAG中，和大模型抽取关键词相比如何）提取出文档的十个关键词，放在每个段落之前。\n（3）**Coreference resolution（共指消解）：**使用SpanBERT-large model，采用c2f-coref方法，在OntoNotes上微调。然后用模型对文档生成代词-先行词映射。将代词与文档中最早出现的先行词关联。将先行词放入括号，附在对应的代词后面。比如 “曾在该场地（xx剧场）”\n5.result 5.1混合检索\nrank fusion略好于hierarchical，但都不能解决NQ-Hard问题。说明这两种方法都只能提高自包含问题的表现。\n统计了检索性能随融合权重变化的曲线。发现NQ上的最佳融合权重不能直接转移到NQ-hard上。\n5.2上下文化段落表示\n添加标题和关键词都相当于添加摘要，提升效果相当；共指消解表现最差。\n在NQ-Hard问题（需要连接上下文的问题）的表现显著优于混合检索。\n6.Disscution 1.为什么混合检索在Hard问题上表现不佳\n通过MaxP方法将查询-段落的指标转为查询-文档的指标，作者发现rank fusion和hierarchical检索出的文档大都正确，说明它能找到相关文档，但段落排序表现非常差，说明这两种方法不能够有效的对段落进行排序。\n另外，作者提到fusion weight 在 NQ-Hard和普通问题中的变化趋势不同。所以使用混合检索不能同时在两类问题上达到最佳表现。\n2.为什么在Genomics上上下文表示结果变差\n计算了加/不加标题的文档与query的Jaccard相似度，只有Genomics加标题后值减小。说明添加标题引入了更多不相关的内容，帮倒忙。\nJaccard 相似度公式：$\\text{Jaccard}(A, B) = \\frac{|A \\cap B|}{|A \\cup B|}$\n$A $ 和$B $：两个文本的词集合（或更广义的集合）。 $|A \\cap B|$: A 和 B 中**共同词（交集）**的数量。 $|A \\cup B| $: A 和 B 中**所有唯一词（并集）**的数量。 取值范围 $[0, 1]$（0 表示无重叠，1 表示完全一致）。\n优点：\n简单直观，适用于短文本或集合型数据 不依赖词序或语义（仅统计词重叠） 缺点：\n忽略语义：同义词（如“电脑”和“计算机”）会被视为不同词。 敏感于词频：未考虑词的重要性（如TF-IDF），可以给词添加权重作为改进。 长文本效果差：并集会急剧增大，导致相似度被低估。 3.错误分析\n在两种融合检索、三种上下文化的方法下，多跳推理MHR最难解决，缩写最易解决。使用共指消解不如直接添加标题，因为标题往往含有核心词，而共指消解多次在段落中插入内容，反而干扰了匹配。\n该文章中了ACL2024。在连接上下文方面使用的方法比较淳朴。主要是定义了NQ-Hard数据集，并在5个数据集、原始方法+2个混合检索+3个上下文检索上做了一系列实验，并很好的解释了现象。\n复现 把README里的loaddata和evaluation的代码复制到dapr根目录load.py和eval.py下\npip install -r requirements.txt\n有setup.py，在根目录下python setup.py build python setup.py install 解决module’dapr’ not found\nsudo apt-get update\nConditionalQA数据集 ConditionalQA给定提问者特定情况下的情景，回答与英国政策相关的问题。每个问答实例都标注了来自英国政府政策网页的证据。我们将原始数据集中的所有此类网页作为语料库。每个网页最初被解析为HTML标签，我们将其视为段落，移除HTML标签，仅保留纯自然语言。对于每个问答实例，我们将情景和问题连接起来形成一个查询，并将相应的证据视为黄金相关段落。\n预处理后的train（原版的数据没有文章和句子的id，这是处理后的数据）\n{ \"query\": { \"id\": \"train-0\", //train条目编号 \"text\": \"My father, who was a widower and the owner of several large properties in Wales, died recently and apparently intestate. My paternal uncle is applying for probate, but I believe that I have a stronger claim. Do I have a greater right to probate in respect of my late father's estate?\" }, \"judged_chunks\": [ //判断点，一个问题可能有多个黄金段落 { \"chunk\": { \"id\": \"74-24\", \"text\": \"You can apply to become the estate’s administrator if you are 18 or over and you are the most ‘entitled’ inheritor of the deceased’s estate. This is usually the deceased’s closest living relative.\n\" }, \"judgement\": 1, //都为1 \"belonging_doc\": { //每个chunk都把\"belonging_doc\"详细写了一遍，导致文件很大 \"id\": \"74\", \"title\": \"Applying for probate\", \"chunks\": [ { \"id\": \"74-0\", \"text\": \"Overview\" }, ... { \"id\": \"74-138\", \"text\": \"Once you have probate you can start dealing with the estate.\" } ], \"candidate_chunk_ids\": [ \"74-5\", ... \"74-51\" ] } } ... ] } 预处理后的test\n{ \"query\": { \"id\": \"dev-0\", //问题编号 \"text\": \"My brother and his wife are in prison for carrying out a large fraud scheme. Their 7 and 8 year old children have been living with me for the last 4 years. I want to become their Special Guardian to look after them permanently How long will it be before I hear back from the court?\" }, //具体问题 \"judged_chunks\": [ { \"chunk\": { \"id\": \"86-41\", //黄金匹配段落 \"text\": \"Within 10 days of receiving your application the court will send you a case number and a date for a meeting to set out:\n\" }, \"judgement\": 1, //不知道什么意思，取值应该全部为1 \"belonging_doc\": { \"id\": \"86\", \"title\": \"Become a special guardian\", \"chunks\": [ //chunks是该问题相关的法条界面的文本分割后的结果。一段话设置为一个chunk { \"id\": \"86-0\", \"text\": \"What is a special guardian\" }, { \"id\": \"86-1\", \"text\": \"You can apply to be a child’s special guardian when they cannot live with their birth parents and adoption is not right for them.\" }, ... { \"id\": \"86-62\", \"text\": \"You might be able to get a special guardian allowance from the children’s services department of your local council.\" } ], \"candidate_chunk_ids\": [ //把chunkid重新排了一遍，不知道按照什么要求排的 \"86-6\", \"86-52\", ... \"86-57\", \"86-14\", \"86-2\", \"86-16\" ] } } ] } prepending_titles/bm25/CQA\nquery是一个字典，包括id，content。DAPR把每句话所属文章的标题也作为一个title字段加进去了。比如{\"id\": \"0-0\", \"title\": \"Child Tax Credit\", \"contents\": \"Overview\"}\n这里的bm25使用了pyserini，是用java实现的。然后把corpus字典传给java接口去index。应该是把title和content并为一个字符串。而且是以一句话而不是一篇文章进行的index。\n那对于NQ这种没有文章标题，只有零散段落的怎么prepending_titles呢？\n","wordCount":"643","inLanguage":"en","datePublished":"2025-05-02T16:41:03+08:00","dateModified":"2025-05-02T16:41:03+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://Rook1eChan.github.io/posts/dapr-a-benchmark-on-document-aware-passage-retrieval/"},"publisher":{"@type":"Organization","name":"Chan's Blog","logo":{"@type":"ImageObject","url":"https://Rook1eChan.github.io/apple-touch-icon.png"}}}</script><script>MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]]}}</script><script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://Rook1eChan.github.io/ accesskey=h title="Chan's Blog (Alt + H)"><img src=https://Rook1eChan.github.io/apple-touch-icon.png alt aria-label=logo height=35>Chan's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://Rook1eChan.github.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://Rook1eChan.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://Rook1eChan.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">DAPR A Benchmark on Document-Aware Passage Retrieval</h1><div class=post-meta><span title='2025-05-02 16:41:03 +0800 +0800'>May 2, 2025</span></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#1motivation aria-label=1.Motivation>1.Motivation</a></li><li><a href=#2related-work aria-label="2.Related work">2.Related work</a></li><li><a href=#3method aria-label=3.Method>3.Method</a><ul><li><a href=#31nq-hard aria-label=3.1NQ-Hard>3.1NQ-Hard</a></li><li><a href=#32datasets aria-label=3.2Datasets>3.2Datasets</a></li><li><a href=#33evaluation aria-label=3.3Evaluation>3.3Evaluation</a></li></ul></li><li><a href=#4experiments aria-label=4.Experiments>4.Experiments</a><ul><li><a href=#41%e5%9f%ba%e7%a1%80%e6%a3%80%e7%b4%a2%e5%99%a8 aria-label=4.1基础检索器>4.1基础检索器</a></li><li><a href=#42%e4%b8%a4%e7%a7%8d%e5%b0%86%e4%b8%8a%e4%b8%8b%e6%96%87%e5%bc%95%e5%85%a5%e7%a5%9e%e7%bb%8f%e6%a3%80%e7%b4%a2%e5%99%a8%e7%9a%84%e6%96%b9%e6%b3%95 aria-label=4.2两种将上下文引入神经检索器的方法>4.2两种将上下文引入神经检索器的方法</a><ul><li><a href=#421%e5%8a%a0%e5%85%a5bm25%e7%9a%84%e6%b7%b7%e5%90%88%e6%a3%80%e7%b4%a2 aria-label=4.2.1加入BM25的混合检索>4.2.1加入BM25的混合检索</a></li><li><a href=#422%e4%b8%8a%e4%b8%8b%e6%96%87%e5%8c%96%e7%9a%84%e6%ae%b5%e8%90%bd%e8%a1%a8%e7%a4%ba aria-label=4.2.2上下文化的段落表示>4.2.2上下文化的段落表示</a></li></ul></li></ul></li><li><a href=#5result aria-label=5.result>5.result</a></li><li><a href=#6disscution aria-label=6.Disscution>6.Disscution</a></li><li><a href=#%e5%a4%8d%e7%8e%b0 aria-label=复现>复现</a><ul><li><a href=#conditionalqa%e6%95%b0%e6%8d%ae%e9%9b%86 aria-label=ConditionalQA数据集>ConditionalQA数据集</a></li></ul></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h2 id=1motivation>1.Motivation<a hidden class=anchor aria-hidden=true href=#1motivation>#</a></h2><p>现有的神经检索（neural retrieval）的方法主要集中在短文本排序，在长篇文章中做检索效果并不好（由于自注意力机制token数量的限制；或者返回的文档过长，不便于用户使用）。另外，作者发现在先进检索器的检索错误中，半数错误与缺少上下文有关。</p><p>比如：在A剧场中演出过的演员有哪些？如果只检索关键字“A剧场”，可能找不到答案，需要结合上下文找到“……在这里演出过……”的内容才是真正答案。</p><p>因此，作者针对上下文强关联的任务建立了一个数据集，使用两类方法（hybrid retrieval with BM25、 contextualized passage representations）进行实验，并详细解释了实验结果。</p><br><h2 id=2related-work>2.Related work<a hidden class=anchor aria-hidden=true href=#2related-work>#</a></h2><ul><li><strong>Document Question Answering（DocQA）</strong>：要求模型回答关于输入文档的问题，通常假设文档在提问前就已给出。本文提出的(Document-Awarepassage Retrieval, DAPR)与DocQA类似，区别在于DAPR希望用户提问时不知道目标文档，由模型来寻找目标文档。</li><li><strong>Long-document retrieval（长文档检索）</strong>：对于长文档检索有一些简单的方法：将文档中段落相关性的最大值作为文档的相关性（MaxP）；仅编码文档中的第一个段落（FirstP）……与DAPR相比，所有这些先前的工作都没有研究如何在考虑文档上下文的情况下检索段落。</li><li><strong>Hybrid retrieval（混合检索）</strong>：对于一个查询使用多个检索系统（常常是BM25+神经检索）<ul><li>rank fusion（排名融合）——通过凸组合、互逆排名等方法将不同检索系统的个体排名合并为一个。</li><li>hierarchical retrieval（层次检索）——首先检索文档，然后从这些文档中检索段落。只适用于段落本身足以对查询做出响应的情况。</li><li>本文探讨了段落排名和文档排名结合的有效性。</li></ul></li><li><strong>Relation to pre-training tasks（和预训练任务的关系）</strong>：有的研究在预训练中加入上下文。但推理时仍然只关注独立的段落。</li><li>补充：<ul><li>NQ：谷歌的一个问答数据集</li><li>NDCG：评价检索序列的相关性和位置</li><li>共指信息：描述文本中不同表达式指向同一实体或概念的语言现象，如*“玛丽打开了门，<strong>她</strong>随后拿起包。”* → “她”与“玛丽”共指同一人。</li><li>共指消解（Coreference Resolution）：自动识别文本中所有指向同一实体的表达式并分组。</li></ul></li></ul><br><h2 id=3method>3.Method<a hidden class=anchor aria-hidden=true href=#3method>#</a></h2><p>DAPR任务要求系统提取+排序。给出段落集合$C$，文档集合$D$，对于查询集合$q \in Q$，检索系统$s$应该提取出最好的$K$个段落集合$R$。</p><h3 id=31nq-hard>3.1NQ-Hard<a hidden class=anchor aria-hidden=true href=#31nq-hard>#</a></h3><p>对SOTA的检索器（DRAGON+,SPLADEv2, and ColBERTv2)使用NQ数据集，发现一半的错误来自于不了解上下文。将这些数据命名为<strong>NQ-hard</strong>，并分为4类：</p><ol><li>共指消解（CR）：关键的共指信息需要通过特定文档上下文来解析；</li><li>主要主题（MT）：只有了解文档的背景主题（通常是标题），才能回答查询；</li><li>多跳推理（MHR）：连接查询和查询相关段落中的实体的推理路径包括文档上下文中的其他节点；</li><li>缩写（AC）：在相关段落（或查询）中出现一个缩写，该缩写对应于查询（或相关段落）中的全称，文档上下文解释了这种映射；</li></ol><p><img alt=nqques loading=lazy src=/DAPR/NQques.png></p><br><h3 id=32datasets>3.2Datasets<a hidden class=anchor aria-hidden=true href=#32datasets>#</a></h3><p>MS MARCO、Natural Questions、MIRACL、Genomics 和 ConditionalQA（具体处理方式见附录A）有语料库的直接用，没有的把黄金段落文本收集起来当语料库。（也是很神奇）</p><br><h3 id=33evaluation>3.3Evaluation<a hidden class=anchor aria-hidden=true href=#33evaluation>#</a></h3><p>使用<strong>nDCG@10</strong>和recall@100做指标。</p><p>将binary/3-scale转换为0-1/0-1-2，然后使用pytrec_eval计算指标。</p><p>考虑到现实世界中的检索系统多用于零样本、跨领域的情景，本文进行了一项测试：在MS MARCO训练集训练，然后在MS MARCO测试集测试，作为域内评估；在其它四个数据集上测试，作为域外评估。</p><br><h2 id=4experiments>4.Experiments<a hidden class=anchor aria-hidden=true href=#4experiments>#</a></h2><h3 id=41基础检索器>4.1基础检索器<a hidden class=anchor aria-hidden=true href=#41基础检索器>#</a></h3><ul><li>BM25（使用PySerini的默认配置）</li><li>neural retrievers：DRAGON+、SPLADEv2、ColBERTv2（在MS MARCO上训练）</li></ul><br><h3 id=42两种将上下文引入神经检索器的方法>4.2两种将上下文引入神经检索器的方法<a hidden class=anchor aria-hidden=true href=#42两种将上下文引入神经检索器的方法>#</a></h3><h4 id=421加入bm25的混合检索>4.2.1加入BM25的混合检索<a hidden class=anchor aria-hidden=true href=#421加入bm25的混合检索>#</a></h4><p><strong>（1）Rank fusion融合检索</strong></p><p>由于神经网络适合于检测512tokens内的段落，而BM25无长度限制，所以使用BM25检索整个文档，而使用神经检索器检索段落。</p><p>相关性分数为：</p>$$s_{convex}(q,p,d)=\alpha\hat s_{BM25}(q,p) + (1-\alpha)\hat s_{nueral}(q,d)$$<p>（公式有误）</p><p>$\hat s_{BM25},\hat s_{nueral}$的分数都是归一化的。归一化公式为：</p>$$\hat{s}(q, c) = \frac{s(q, c) - m_q}{M_q - m_q}$$<p>​</p><ul><li>$s(q, c)$：检索器对查询(q)和候选文本(c)（段落或文档）的原始分数。</li><li>$m_q和M_q$：当前查询(q)的Top候选结果中分数的最小值和最大值。</li><li>若候选文本(c)在某一检索器的结果中缺失（未进入Top列表），则其分数视为0。</li></ul><blockquote><p>分数计算示例：</p><p>输入数据:</p><ol><li><strong>5篇文章</strong>，每篇2个段落：</li></ol><ul><li>文章D1：段落P1, P2</li><li>文章D2：段落P3, P4</li><li>文章D3：段落P5, P6</li><li>文章D4：段落P7, P8</li><li>文章D5：段落P9, P10</li></ul><ol start=2><li><strong>文档级检索结果</strong> (topk=2)：</li></ol><ul><li>得分：D1=0.8, D2=0.6（其他文档得分低于这两个）</li></ul><ol start=3><li><strong>段落级检索结果</strong> (topk=2)：</li></ol><ul><li>得分：P3=0.9, P5=0.7（其他段落得分低于这两个）</li></ul><ol start=4><li><strong>段落到文档映射</strong>：</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>pid2did</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=s1>&#39;P1&#39;</span><span class=p>:</span><span class=s1>&#39;D1&#39;</span><span class=p>,</span> <span class=s1>&#39;P2&#39;</span><span class=p>:</span><span class=s1>&#39;D1&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=s1>&#39;P3&#39;</span><span class=p>:</span><span class=s1>&#39;D2&#39;</span><span class=p>,</span> <span class=s1>&#39;P4&#39;</span><span class=p>:</span><span class=s1>&#39;D2&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=s1>&#39;P5&#39;</span><span class=p>:</span><span class=s1>&#39;D3&#39;</span><span class=p>,</span> <span class=s1>&#39;P6&#39;</span><span class=p>:</span><span class=s1>&#39;D3&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=s1>&#39;P7&#39;</span><span class=p>:</span><span class=s1>&#39;D4&#39;</span><span class=p>,</span> <span class=s1>&#39;P8&#39;</span><span class=p>:</span><span class=s1>&#39;D4&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=s1>&#39;P9&#39;</span><span class=p>:</span><span class=s1>&#39;D5&#39;</span><span class=p>,</span> <span class=s1>&#39;P10&#39;</span><span class=p>:</span><span class=s1>&#39;D5&#39;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ol start=5><li><strong>段落权重</strong>：假设<code>passage_weight=0.4</code>（文档权重自动为0.6）</li></ol><p>计算过程:</p><ol><li><strong>构建得分映射</strong>：</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>did2score</span> <span class=o>=</span> <span class=p>{</span><span class=s1>&#39;D1&#39;</span><span class=p>:</span><span class=mf>0.8</span><span class=p>,</span> <span class=s1>&#39;D2&#39;</span><span class=p>:</span><span class=mf>0.6</span><span class=p>}</span>  <span class=c1># 文档级top2</span>
</span></span><span class=line><span class=cl><span class=n>pid2score</span> <span class=o>=</span> <span class=p>{</span><span class=s1>&#39;P3&#39;</span><span class=p>:</span><span class=mf>0.9</span><span class=p>,</span> <span class=s1>&#39;P5&#39;</span><span class=p>:</span><span class=mf>0.7</span><span class=p>}</span>  <span class=c1># 段落级top2</span>
</span></span></code></pre></div><ol start=2><li><strong>传播文档得分到段落</strong>：</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>doc_pid2score</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=s1>&#39;P3&#39;</span><span class=p>:</span> <span class=n>did2score</span><span class=p>[</span><span class=s1>&#39;D2&#39;</span><span class=p>],</span>  <span class=c1># P3属于D2 → 0.6</span>
</span></span><span class=line><span class=cl>    <span class=s1>&#39;P5&#39;</span><span class=p>:</span> <span class=n>did2score</span><span class=p>[</span><span class=s1>&#39;D3&#39;</span><span class=p>]</span>   <span class=c1># 但D3不在did2score中(文档级只返回了D1,D2)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>实际结果只有<code>{'P3':0.6}</code>，因为D3不在文档级top2中</p><ol start=3><li><strong>M2C2融合</strong>（假设是线性加权）：</li></ol><ul><li>对P3：<ul><li>文档得分：0.6</li><li>段落得分：0.9</li><li>融合得分 = 0.6*0.6 + 0.9*0.4 = 0.36 + 0.36 = 0.72</li></ul></li><li>对P5：<ul><li>文档得分：无 → 可能视为0或忽略</li><li>段落得分：0.7</li><li>如果忽略文档部分：0.7*0.4 = 0.28</li></ul></li></ul><ol start=4><li><strong>最终融合结果</strong>：</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>fused</span> <span class=o>=</span> <span class=p>{</span><span class=s1>&#39;P3&#39;</span><span class=p>:</span><span class=mf>0.72</span><span class=p>,</span> <span class=s1>&#39;P5&#39;</span><span class=p>:</span><span class=mf>0.28</span><span class=p>}</span>
</span></span></code></pre></div></blockquote><br><p><strong>（2）Hierarchical retrieval层次检索</strong></p><p>第一步先BM25检索文档，第二步神经检索搜索段落，并在第二步应用带有分数归一化的排名融合。</p><br><h4 id=422上下文化的段落表示>4.2.2上下文化的段落表示<a hidden class=anchor aria-hidden=true href=#422上下文化的段落表示>#</a></h4><p>（1）**Prepending titles：**将文章标题放在每个段落的开头，并用特殊标记分割。可能会出现文档无标题或标题无意义。</p><p>（2）**Prepending document keyphrases：**使用TopicRank算法（不知道在RAG中，和大模型抽取关键词相比如何）提取出文档的十个关键词，放在每个段落之前。</p><p>（3）**Coreference resolution（共指消解）：**使用SpanBERT-large model，采用c2f-coref方法，在OntoNotes上微调。然后用模型对文档生成代词-先行词映射。将代词与文档中最早出现的先行词关联。将先行词放入括号，附在对应的代词后面。比如 “<em>曾在该场地（xx剧场）</em>”</p><br><h2 id=5result>5.result<a hidden class=anchor aria-hidden=true href=#5result>#</a></h2><p><img alt=result loading=lazy src=/DAPR/result.png></p><p><strong>5.1混合检索</strong></p><p>rank fusion略好于hierarchical，但都不能解决NQ-Hard问题。说明这两种方法都只能提高自包含问题的表现。</p><p>统计了检索性能随融合权重变化的曲线。发现NQ上的最佳融合权重不能直接转移到NQ-hard上。</p><br><p><strong>5.2上下文化段落表示</strong></p><p>添加标题和关键词都相当于添加摘要，提升效果相当；共指消解表现最差。</p><p>在NQ-Hard问题（需要连接上下文的问题）的表现显著优于混合检索。</p><br><h2 id=6disscution>6.Disscution<a hidden class=anchor aria-hidden=true href=#6disscution>#</a></h2><p><strong>1.为什么混合检索在Hard问题上表现不佳</strong></p><p>通过MaxP方法将查询-段落的指标转为查询-文档的指标，作者发现rank fusion和hierarchical检索出的文档大都正确，说明它<u>能找到相关文档</u>，但段落排序表现非常差，说明这两种方法<u>不能够有效的对段落进行排序。</u></p><p>另外，作者提到fusion weight 在 NQ-Hard和普通问题中的变化趋势不同。所以使用混合检索不能同时在两类问题上达到最佳表现。</p><p><img alt=WEIGHT loading=lazy src=/DAPR/weight.png></p><br><p><strong>2.为什么在Genomics上上下文表示结果变差</strong></p><p>计算了加/不加标题的文档与query的Jaccard相似度，只有Genomics加标题后值减小。说明添加标题引入了更多不相关的内容，帮倒忙。</p><blockquote><p>Jaccard 相似度公式：$\text{Jaccard}(A, B) = \frac{|A \cap B|}{|A \cup B|}$</p><ul><li>$A $ 和$B $：两个文本的词集合（或更广义的集合）。</li><li>$|A \cap B|$: A 和 B 中**共同词（交集）**的数量。</li><li>$|A \cup B| $: A 和 B 中**所有唯一词（并集）**的数量。</li></ul><p><strong>取值范围</strong> $[0, 1]$（0 表示无重叠，1 表示完全一致）。</p><p><strong>优点</strong>：</p><ul><li>简单直观，适用于短文本或集合型数据</li><li>不依赖词序或语义（仅统计词重叠）</li></ul><p><strong>缺点</strong>：</p><ul><li><strong>忽略语义</strong>：同义词（如“电脑”和“计算机”）会被视为不同词。</li><li><strong>敏感于词频</strong>：未考虑词的重要性（如TF-IDF），可以给词添加权重作为改进。</li><li><strong>长文本效果差</strong>：并集会急剧增大，导致相似度被低估。</li></ul></blockquote><br><p><strong>3.错误分析</strong></p><p>在两种融合检索、三种上下文化的方法下，多跳推理MHR最难解决，缩写最易解决。使用共指消解不如直接添加标题，因为标题往往含有核心词，而共指消解多次在段落中插入内容，反而干扰了匹配。</p><br><p><em>该文章中了ACL2024。在连接上下文方面使用的方法比较淳朴。主要是定义了NQ-Hard数据集，并在5个数据集、原始方法+2个混合检索+3个上下文检索上做了一系列实验，并很好的解释了现象。</em></p><br><h2 id=复现>复现<a hidden class=anchor aria-hidden=true href=#复现>#</a></h2><p>把README里的loaddata和evaluation的代码复制到dapr根目录load.py和eval.py下</p><p>pip install -r requirements.txt</p><p>有setup.py，在根目录下python setup.py build python setup.py install 解决module&rsquo;dapr&rsquo; not found</p><p>sudo apt-get update</p><h3 id=conditionalqa数据集>ConditionalQA数据集<a hidden class=anchor aria-hidden=true href=#conditionalqa数据集>#</a></h3><p>ConditionalQA给定提问者特定情况下的情景，回答与英国政策相关的问题。每个问答实例都标注了来自英国政府政策网页的证据。我们将原始数据集中的所有此类网页作为语料库。每个网页最初被解析为HTML标签，我们将其视为段落，移除HTML标签，仅保留纯自然语言。对于每个问答实例，我们将情景和问题连接起来形成一个查询，并将相应的证据视为黄金相关段落。</p><p>预处理后的train（原版的数据没有文章和句子的id，这是处理后的数据）</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-json data-lang=json><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nt>&#34;query&#34;</span><span class=p>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nt>&#34;id&#34;</span><span class=p>:</span> <span class=s2>&#34;train-0&#34;</span><span class=p>,</span>  <span class=c1>//train条目编号
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nt>&#34;text&#34;</span><span class=p>:</span> <span class=s2>&#34;My father, who was a widower and the owner of several large properties in Wales, died recently and apparently intestate. My paternal uncle is applying for probate, but I believe that I have a stronger claim. Do I have a greater right to probate in respect of my late father&#39;s estate?&#34;</span>
</span></span><span class=line><span class=cl>  <span class=p>},</span>
</span></span><span class=line><span class=cl>  <span class=nt>&#34;judged_chunks&#34;</span><span class=p>:</span> <span class=p>[</span>  <span class=c1>//判断点，一个问题可能有多个黄金段落
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nt>&#34;chunk&#34;</span><span class=p>:</span> <span class=p>{</span>  
</span></span><span class=line><span class=cl>        <span class=nt>&#34;id&#34;</span><span class=p>:</span> <span class=s2>&#34;74-24&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=nt>&#34;text&#34;</span><span class=p>:</span> <span class=s2>&#34;&lt;p&gt;You can apply to become the estate’s administrator if you are 18 or over and you are the most ‘entitled’ inheritor of the deceased’s estate. This is usually the deceased’s closest living relative.&lt;/p&gt;&#34;</span>
</span></span><span class=line><span class=cl>      <span class=p>},</span>
</span></span><span class=line><span class=cl>      <span class=nt>&#34;judgement&#34;</span><span class=p>:</span> <span class=mi>1</span><span class=p>,</span>   <span class=c1>//都为1
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=nt>&#34;belonging_doc&#34;</span><span class=p>:</span> <span class=p>{</span>  <span class=c1>//每个chunk都把&#34;belonging_doc&#34;详细写了一遍，导致文件很大
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nt>&#34;id&#34;</span><span class=p>:</span> <span class=s2>&#34;74&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=nt>&#34;title&#34;</span><span class=p>:</span> <span class=s2>&#34;Applying for probate&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=nt>&#34;chunks&#34;</span><span class=p>:</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>          <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nt>&#34;id&#34;</span><span class=p>:</span> <span class=s2>&#34;74-0&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=nt>&#34;text&#34;</span><span class=p>:</span> <span class=s2>&#34;Overview&#34;</span>
</span></span><span class=line><span class=cl>          <span class=p>},</span>
</span></span><span class=line><span class=cl>          <span class=err>...</span>
</span></span><span class=line><span class=cl>          <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nt>&#34;id&#34;</span><span class=p>:</span> <span class=s2>&#34;74-138&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=nt>&#34;text&#34;</span><span class=p>:</span> <span class=s2>&#34;Once you have probate you can start dealing with the estate.&#34;</span>
</span></span><span class=line><span class=cl>          <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>],</span>
</span></span><span class=line><span class=cl>        <span class=nt>&#34;candidate_chunk_ids&#34;</span><span class=p>:</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>          <span class=s2>&#34;74-5&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>          <span class=err>...</span>
</span></span><span class=line><span class=cl>          <span class=s2>&#34;74-51&#34;</span>
</span></span><span class=line><span class=cl>        <span class=p>]</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=err>...</span>
</span></span><span class=line><span class=cl>  <span class=p>]</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>预处理后的test</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-json data-lang=json><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nt>&#34;query&#34;</span><span class=p>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nt>&#34;id&#34;</span><span class=p>:</span> <span class=s2>&#34;dev-0&#34;</span><span class=p>,</span>  <span class=c1>//问题编号
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nt>&#34;text&#34;</span><span class=p>:</span> <span class=s2>&#34;My brother and his wife are in prison for carrying out a large fraud scheme. Their 7 and 8 year old children have been living with me for the last 4 years. I want to become their Special Guardian to look after them permanently How long will it be before I hear back from the court?&#34;</span>
</span></span><span class=line><span class=cl>  <span class=p>},</span>  <span class=c1>//具体问题
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=nt>&#34;judged_chunks&#34;</span><span class=p>:</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nt>&#34;chunk&#34;</span><span class=p>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nt>&#34;id&#34;</span><span class=p>:</span> <span class=s2>&#34;86-41&#34;</span><span class=p>,</span> <span class=c1>//黄金匹配段落
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nt>&#34;text&#34;</span><span class=p>:</span> <span class=s2>&#34;&lt;p&gt;Within 10 days of receiving your application the court will send you a case number and a date for a meeting to set out:&lt;/p&gt;&#34;</span>
</span></span><span class=line><span class=cl>      <span class=p>},</span>
</span></span><span class=line><span class=cl>      <span class=nt>&#34;judgement&#34;</span><span class=p>:</span> <span class=mi>1</span><span class=p>,</span>  <span class=c1>//不知道什么意思，取值应该全部为1
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=nt>&#34;belonging_doc&#34;</span><span class=p>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nt>&#34;id&#34;</span><span class=p>:</span> <span class=s2>&#34;86&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=nt>&#34;title&#34;</span><span class=p>:</span> <span class=s2>&#34;Become a special guardian&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=nt>&#34;chunks&#34;</span><span class=p>:</span> <span class=p>[</span> <span class=c1>//chunks是该问题相关的法条界面的文本分割后的结果。一段话设置为一个chunk
</span></span></span><span class=line><span class=cl><span class=c1></span>          <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nt>&#34;id&#34;</span><span class=p>:</span> <span class=s2>&#34;86-0&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=nt>&#34;text&#34;</span><span class=p>:</span> <span class=s2>&#34;What is a special guardian&#34;</span>
</span></span><span class=line><span class=cl>          <span class=p>},</span>
</span></span><span class=line><span class=cl>          <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nt>&#34;id&#34;</span><span class=p>:</span> <span class=s2>&#34;86-1&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=nt>&#34;text&#34;</span><span class=p>:</span> <span class=s2>&#34;You can apply to be a child’s special guardian when they cannot live with their birth parents and adoption is not right for them.&#34;</span>
</span></span><span class=line><span class=cl>          <span class=p>},</span>
</span></span><span class=line><span class=cl>          <span class=err>...</span>
</span></span><span class=line><span class=cl>          <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nt>&#34;id&#34;</span><span class=p>:</span> <span class=s2>&#34;86-62&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=nt>&#34;text&#34;</span><span class=p>:</span> <span class=s2>&#34;You might be able to get a special guardian allowance from the children’s services department of your local council.&#34;</span>
</span></span><span class=line><span class=cl>          <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>],</span>
</span></span><span class=line><span class=cl>        <span class=nt>&#34;candidate_chunk_ids&#34;</span><span class=p>:</span> <span class=p>[</span> <span class=c1>//把chunkid重新排了一遍，不知道按照什么要求排的
</span></span></span><span class=line><span class=cl><span class=c1></span>          <span class=s2>&#34;86-6&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>          <span class=s2>&#34;86-52&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>          <span class=err>...</span>
</span></span><span class=line><span class=cl>          <span class=s2>&#34;86-57&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>          <span class=s2>&#34;86-14&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>          <span class=s2>&#34;86-2&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>          <span class=s2>&#34;86-16&#34;</span>
</span></span><span class=line><span class=cl>        <span class=p>]</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>]</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><strong>prepending_titles/bm25/CQA</strong></p><p>query是一个字典，包括id，content。DAPR把每句话所属文章的标题也作为一个title字段加进去了。比如<code>{"id": "0-0", "title": "Child Tax Credit", "contents": "Overview"}</code></p><p>这里的bm25使用了pyserini，是用java实现的。然后把corpus字典传给java接口去index。应该是把title和content并为一个字符串。而且是以一句话而不是一篇文章进行的index。</p><p>那对于NQ这种没有文章标题，只有零散段落的怎么prepending_titles呢？</p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><link href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;700&family=JetBrains+Mono&display=swap" rel=stylesheet><footer class=footer><span>&copy; 2025 <a href=https://Rook1eChan.github.io/>Chan's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>