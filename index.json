[{"content":"CDF-RAG: Causal Dynamic Feedback for Adaptive Retrieval-Augmented Generation\n只挂了arxiv，粗看，了解一下各模块的实现方式。\n1.Motivation 现有的RAG框架主要是静态检索，且依赖于语义相似性和关联性，这些方法优先考虑主题相关的文档，而并非提供解释或因果关系的文档。这导致响应结果是基于事实的，但是没能理解因果关系。\n此外，基于大规模观察语料库训练的语言模型倾向于建模共现模式而非因果依赖，这使得它们容易将相关性与因果关系混淆——尤其是在存在不完整或模糊证据的情况下。这些局限性在多跳检索中尤为明显。\n另外，用户的提问可能是模糊的，现有机制缺乏动态适应和因果机制。\n2.Contributions 本文提出了CDFRAG框架，将强化学习查询优化、多跳因果图检索和基于对齐的幻觉检测整合到一个推理循环中。\n证明了基于强化学习的查询重写显著提升了多跳因果推理和检索质量，优于先前的细化方法。\n本方法在四个数据集中均sota，在因果正确性、一致性和可解释性方面均有所改进。\n3.Method 1.构建因果知识图谱 使用UniCausal提取因果对（Causal，Effect）。经过GPT4验证后，编码为（C，E，Relation）并存入有向图G。\n2.根据强化学习进行查询重写 给定用户初始查询q，重写q的过程是一个马尔可夫决策过程（MDP），有三种操作：\n扩展：添加相关的因果因素 简化：去除多余的细节 分解：复杂查询拆解为子查询 策略通过SFT微调生成，然后使用PPO优化。\n监督微调（Supervised Fine-Tuning, SFT） 目的：用标注的示范数据（如人工修正的样本）初始化策略 (\\pi_\\theta(a|s))，使其初步具备期望的行为模式。 方法：通过最大化对数似然来微调模型参数，损失函数为： $L_{\\text{SFT}} = -\\sum_{t=1}^{T} \\log P_\\phi(y_t \\mid y_{\u0026lt;t}, x)$ $y_t$ 是时间步 $t$ 的正确动作（或词元）。 $y_{\u0026lt;t}$ 表示历史信息（之前的动作或上下文）。 $x$ 是输入状态（如提示或环境状态）。 核心是让模型输出的概率分布贴近人工标注的数据。 近端策略优化（Proximal Policy Optimization, PPO） 目的：在SFT的基础上，通过与环境交互进一步优化策略，平衡探索与利用，同时避免训练不稳定。 损失函数： $L_{\\text{PPO}}(\\theta) = \\mathbb{E}_t \\left[ \\min\\left( \\text{比率项} \\cdot A_t, \\text{截断后的比率项} \\cdot A_t \\right) \\right]$ 比率项：新策略与旧策略的概率比 $\\frac{\\pi_\\theta(a|s)}{\\pi_{\\theta_{old}}(at|st)}$，衡量策略变化程度。 优势函数 $A_t$：评估动作 $a$ 在状态 $s$ 下比平均表现好多少（由评论家模型或蒙特卡洛估计）。 截断机制：限制比率项在 $[1-\\epsilon, 1+\\epsilon]$ 之间，防止单步更新过大，确保训练稳定。 3.语义+因果双路径检索 使用MiniLM对优化后的查询进行编码，在向量数据库进行相似性搜索。（整句话编码的稠密检索）\n遍历因果图，沿有向边获取因果信息。\n4.检查输出 对回答计算一个因果一致性分数，如果小于阈值，则在更严格的条件下重新生成回答\n5.幻觉检测和修正 回答和提取出的知识计算幻觉分数，超过阈值则以更严格条件重写\n4.Experiments 1.评估任务\nCosmosQA、MedQA评估常识性和领域特定的因果推理\nMedMCQA、AdversrialQA评估多跳和跨文档推理\n2.基线\n标准RAG方法\n传统RAG，使用BM25\nSmartRAG\nCausalRAG\n查询重写方法\nGymRAG RQRAG 图增强模型\nCausal-First Graph RAG 使用GPT-4、LLaMA 3-8B、Mistral和Flan-T5大模型\n3.评估方法\n传统指标：acc、pre、recall、F1 Context Relevance上下文相关性，通过BRET嵌入后的余弦相似度来量化查询和检索的语义一致性。 因果检索覆盖率（CRC）。CRC反映了系统优先考虑因果证据而非松散关联或语义相关的其他内容的能力。 Groundness，评估生成的答案是否明确得到检索内容的支持。 多个模块拼在一起的模型，基础模块的处理方法可以学习\n","permalink":"https://Rook1eChan.github.io/posts/cdf-rag-causal-dynamic-feedback-for-adaptive-retrieval-augmented-generation/","summary":"\u003cp\u003e\u003ca href=\"https://arxiv.org/abs/2504.12560\"\u003eCDF-RAG: Causal Dynamic Feedback for Adaptive Retrieval-Augmented Generation\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e只挂了arxiv，粗看，了解一下各模块的实现方式。\u003c/p\u003e\n\u003ch2 id=\"1motivation\"\u003e1.Motivation\u003c/h2\u003e\n\u003cp\u003e现有的RAG框架主要是静态检索，且依赖于语义相似性和关联性，这些方法优先考虑主题相关的文档，而并非提供解释或因果关系的文档。这导致响应结果是基于事实的，但是没能理解因果关系。\u003c/p\u003e\n\u003cp\u003e此外，基于大规模观察语料库训练的语言模型倾向于建模共现模式而非因果依赖，这使得它们容易将相关性与因果关系混淆——尤其是在存在不完整或模糊证据的情况下。这些局限性在多跳检索中尤为明显。\u003c/p\u003e\n\u003cp\u003e另外，用户的提问可能是模糊的，现有机制缺乏动态适应和因果机制。\u003c/p\u003e\n\u003ch2 id=\"2contributions\"\u003e2.Contributions\u003c/h2\u003e\n\u003cp\u003e本文提出了CDFRAG框架，将强化学习查询优化、多跳因果图检索和基于对齐的幻觉检测整合到一个推理循环中。\u003c/p\u003e\n\u003cp\u003e证明了基于强化学习的查询重写显著提升了多跳因果推理和检索质量，优于先前的细化方法。\u003c/p\u003e\n\u003cp\u003e本方法在四个数据集中均sota，在因果正确性、一致性和可解释性方面均有所改进。\u003c/p\u003e\n\u003ch2 id=\"3method\"\u003e3.Method\u003c/h2\u003e\n\u003ch3 id=\"1构建因果知识图谱\"\u003e1.构建因果知识图谱\u003c/h3\u003e\n\u003cp\u003e使用UniCausal提取因果对（Causal，Effect）。经过GPT4验证后，编码为（C，E，Relation）并存入有向图G。\u003c/p\u003e\n\u003ch3 id=\"2根据强化学习进行查询重写\"\u003e2.根据强化学习进行查询重写\u003c/h3\u003e\n\u003cp\u003e给定用户初始查询q，重写q的过程是一个马尔可夫决策过程（MDP），有三种操作：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e扩展：添加相关的因果因素\u003c/li\u003e\n\u003cli\u003e简化：去除多余的细节\u003c/li\u003e\n\u003cli\u003e分解：复杂查询拆解为子查询\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e策略通过SFT微调生成，然后使用PPO优化。\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e监督微调（Supervised Fine-Tuning, SFT）\u003c/strong\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e目的\u003c/strong\u003e：用标注的示范数据（如人工修正的样本）初始化策略 (\\pi_\\theta(a|s))，使其初步具备期望的行为模式。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e方法\u003c/strong\u003e：通过最大化对数似然来微调模型参数，损失函数为：\n$L_{\\text{SFT}} = -\\sum_{t=1}^{T} \\log P_\\phi(y_t \\mid y_{\u0026lt;t}, x)$\n\u003cul\u003e\n\u003cli\u003e$y_t$ 是时间步 $t$ 的正确动作（或词元）。\u003c/li\u003e\n\u003cli\u003e$y_{\u0026lt;t}$ 表示历史信息（之前的动作或上下文）。\u003c/li\u003e\n\u003cli\u003e$x$ 是输入状态（如提示或环境状态）。\u003c/li\u003e\n\u003cli\u003e核心是让模型输出的概率分布贴近人工标注的数据。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003e\u003cstrong\u003e近端策略优化（Proximal Policy Optimization, PPO）\u003c/strong\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e目的\u003c/strong\u003e：在SFT的基础上，通过与环境交互进一步优化策略，平衡探索与利用，同时避免训练不稳定。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e损失函数\u003c/strong\u003e：\n$L_{\\text{PPO}}(\\theta) = \\mathbb{E}_t \\left[ \\min\\left( \\text{比率项} \\cdot A_t, \\text{截断后的比率项} \\cdot A_t \\right) \\right]$\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e比率项\u003c/strong\u003e：新策略与旧策略的概率比\u003c/li\u003e\n\u003cli\u003e$\\frac{\\pi_\\theta(a|s)}{\\pi_{\\theta_{old}}(at|st)}$，衡量策略变化程度。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e优势函数 $A_t$\u003c/strong\u003e：评估动作 $a$ 在状态 $s$ 下比平均表现好多少（由评论家模型或蒙特卡洛估计）。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e截断机制\u003c/strong\u003e：限制比率项在 $[1-\\epsilon, 1+\\epsilon]$ 之间，防止单步更新过大，确保训练稳定。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"3语义因果双路径检索\"\u003e3.语义+因果双路径检索\u003c/h3\u003e\n\u003cp\u003e使用MiniLM对优化后的查询进行编码，在向量数据库进行相似性搜索。（整句话编码的稠密检索）\u003c/p\u003e","title":"CDF-RAG: Causal Dynamic Feedback for Adaptive Retrieval-Augmented Generation"},{"content":"github提供给每个用户一个网址，用户可以建立自己的静态网站。\n一、Hugo hugo是一个快速搭建网站的工具，由go语言编写。\n1.安装hugo 到hugo的github标签页Tags · gohugoio/hugo选择一个版本，下载对应的安装包。比如hugo_extended_withdeploy_0.147.0_windows-amd64.zip。\n解压后，在根目录打开cmd，输入\nhugo new site YourSiteName 为你的网站建立文件夹。YourSiteName更改为你的网站的名字。 根目录会出现YourSiteName文件夹。\n3.将根目录的hugo.exe复制到YourSiteName里。 在YourSiteName文件夹里打开cmd，输入\nhugo server -D 会返回如下信息：\n| EN -------------------+----- Pages | 11 Paginator pages | 0 Non-page files | 0 Static files | 0 Processed images | 0 Aliases | 2 Cleaned | 0 Built in 79 ms Environment: \u0026#34;development\u0026#34; Serving pages from disk Running in Fast Render Mode. For full rebuilds on change: hugo server --disableFastRender Web Server is available at http://localhost:1313/ (bind address 127.0.0.1) Press Ctrl+C to stop 在浏览器中输入http://localhost:1313/，显示Page Not Found，说明服务器正常运行，但是此时网站还没有页面。\n2.选择网站主题 在Hugo Themes选择你想要的theme，然后根据theme的安装说明操作就行了。 在此以PaperMod为例。官方安装教程界面：Installation · adityatelange/hugo-PaperMod Wiki\n安装PaperMod，可以：\n在你的网站的theme文件夹使用：\ngit clone https://github.com/adityatelange/hugo-PaperMod themes/PaperMod --depth=1 或者，在Tags · adityatelange/hugo-PaperMod选择版本，下载zip并解压到theme文件夹。\n在你的网站的根文件夹里的hugo.yml文件里添加\ntheme: [\u0026#34;PaperMod\u0026#34;] 3.新建一个笔记 在你的网站的根页面下使用cmd：\nhugo new posts/first.md YourSiteName/content/posts/first.md 就会建立，打开后，内容为：\n--- date: \u0026#39;2025-05-01T18:41:05+08:00\u0026#39; draft: true title: \u0026#39;first\u0026#39; --- 这三条短线围起来的是该笔记的属性。第一行是创建时间；第二行为false时表示草稿状态，改为true才会显示在网站中；第三行为该笔记的标题。之后还可以添加其他的属性。\n打开http://localhost:1313/，刷新后就能看到刚才创建的笔记了。如果没有就重新hugo server -D。\n你可以通过cmd，或者直接新建md文件来添加笔记。\n4.定制个人博客 4.1添加菜单 在hugo.yml文件中添加：\nmenu: main: - identifier: categories name: categories url: /categories/ weight: 10 - identifier: tags name: tags url: /tags/ weight: 20 - identifier: example name: example.org url: https://example.org weight: 30 在网站的右上角就能看到菜单了\n4.2置顶帖子 在笔记的md文件里添加：\n--- ... weight: 1 --- weight为正整数，表示笔记顺序。放到最顶上就设为1。\n4.3hugo.yaml的可选项 hugo.yaml是网站根目录的配置文件\n# 基础配置 baseURL: https://Rook1eChan.github.io # 网站部署的根URL（GitHub Pages地址） languageCode: zh-cn # 网站语言代码（简体中文） title: Chan\u0026#39;s Blog # 网站标题（ theme: [\u0026#34;PaperMod\u0026#34;] # 使用的主题（Hugo PaperMod主题） buildDrafts: false # 构建时是否包含草稿（false表示不构建草稿） # 主题参数配置 params: # 布局控制 ShowBreadCrumbs: true # 显示面包屑导航 ShowReadingTime: false # 隐藏文章阅读时间 ShowShareButtons: false # 隐藏分享按钮 ShowCodeCopyButtons: true # 显示代码复制按钮 # 搜索功能配置（使用Fuse.js） fuseOpts: isCaseSensitive: false # 搜索不区分大小写 shouldSort: true # 对搜索结果排序 location: 0 # 匹配位置权重 distance: 1000 # 匹配距离阈值 threshold: 0.4 # 匹配相似度阈值 minMatchCharLength: 0 # 最小匹配字符长度 keys: [\u0026#34;title\u0026#34;, \u0026#34;permalink\u0026#34;, \u0026#34;summary\u0026#34;, \u0026#34;content\u0026#34;] # 搜索的字段范围 # 首页欢迎信息 homeInfoParams: Title: \u0026#34;你好，欢迎来到我的博客 \\U0001F44B\u0026#34; # 标题 Content: \u0026#34;welcome!\u0026#34; # 内容 # 社交媒体图标 socialIcons: - name: github # GitHub图标 url: \u0026#34;https://github.com/Rook1eChan\u0026#34; # GitHub个人主页 # 其他社交平台（已注释掉） # - name: twitter # url: \u0026#34;twitter.com\u0026#34; # 网站图标配置 assets: favicon: \u0026#34;/apple-touch-icon.png\u0026#34; # favicon路径 # 导航栏图标 label: icon: /apple-touch-icon.png # 导航栏图标路径 iconHeight: 35 # 图标高度（像素） # 输出格式配置 outputs: home: - HTML # 生成HTML页面 - RSS # 生成RSS订阅 - JSON # 生成JSON数据（可能用于搜索） # 内容标记配置 markup: highlight: codeFences: true # 启用代码块高亮 guessSyntax: true # 自动检测代码语言 hl_Lines: \u0026#39;\u0026#39; # 高亮指定行（未设置） lineNos: false # 不显示行号（与下面配置冲突） lineNumbersInTable: true # 用表格布局行号（避免复制时带行号） noClasses: false # 使用CSS类（必须为false） style: github # 代码高亮主题（github、monokai、solarized-dark、dracula） tabWidth: 4 # 代码缩进空格数 goldmark: renderer: unsafe: true # 允许渲染原始HTML/LaTeX math: true # 支持数学公式 # 导航菜单配置 menu: main: # 已注释的分类和标签菜单 # - identifier: categories # name: categories # url: /categories/ # weight: 10 - identifier: search # 搜索菜单项 name: search # 菜单显示名称（英文，与标识不一致） url: /search/ # 搜索页面路径 weight: 25 # 菜单项排序权重 baseURL: 网站的基础URL，这里是 \u0026ldquo;https://Rook1eChan.github.io\u0026rdquo;，必须要写，不然导航出现错误。不要写example.com\nlanguageCode: 网站语言代码，\u0026ldquo;zh-cn\u0026rdquo; 表示简体中文\ntitle: 网站标题\ntheme: 使用的主题\nbuildDrafts: false 表示不设置草稿文章，所有文章都会被展示\n显示相关:\nShowBreadCrumbs: true 显示面包屑导航 ShowReadingTime: false 不显示文章阅读时间 ShowShareButtons: false 不显示分享按钮 ShowCodeCopyButtons: true 显示代码块的复制按钮 搜索功能 (fuseOpts):\n配置了基于 Fuse.js 的搜索功能参数，包括不区分大小写、排序方式等 主页信息 (homeInfoParams):\nTitle：标题 Content：内容 主页社交媒体图标 (socialIcons):\n只启用了 GitHub 链接，指向 \u0026ldquo;https://github.com/Rook1eChan\u0026quot; Twitter 和 Facebook 链接 资源 (assets):\n设置了网站图标 (favicon) 为 \u0026ldquo;/apple-touch-icon.png\u0026rdquo; 标签 (label):\n设置了图标及其高度 指定了主页的输出格式为 HTML、RSS 和 JSON\n主菜单 (main) 中只配置了一个 \u0026ldquo;搜索\u0026rdquo; 项:\n标识符: \u0026ldquo;搜索\u0026rdquo; 名称: \u0026ldquo;search\u0026rdquo; URL: \u0026ldquo;/search/\u0026rdquo; 权重: 25 (用于菜单项排序) 分类和标签菜单项自选\n4.4更改字体 在 Hugo 项目下新建 assets/css/extended/custom.css ，写入\n/* 全局正文字体 - Noto Sans Simplified Chinese */ body, article { font-family: \u0026#34;Noto Sans SC\u0026#34;, sans-serif; } /* 代码块字体 - 保持等宽字体（如 JetBrains Mono 或系统默认） */ pre, code { font-family: \u0026#34;JetBrains Mono\u0026#34;, monospace; font-size: 0.9em; /* 可选：调整代码字体大小 */ } 在 themes/PaperMod/layouts/partials/head.html 中添加 Google Fonts 的链接\n\u0026lt;link href=\u0026#34;https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;700\u0026amp;family=JetBrains+Mono\u0026amp;display=swap\u0026#34; rel=\u0026#34;stylesheet\u0026#34;\u0026gt; 可以去Browse Fonts - Google Fonts选字体。代码怎么写问AI。\n4.5启用数学公式 在themes\\PaperMod\\layouts\\partials\\extend_head.html\u0026quot; 里加上：\n\u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML\u0026#34;\u0026gt; \u0026lt;/script\u0026gt; 在hugo.yaml里加上：\n# 内容标记配置 markup: highlight: codeFences: true # 启用代码块高亮 guessSyntax: true # 自动检测代码语言 hl_Lines: \u0026#39;\u0026#39; # 高亮指定行（未设置） lineNos: false # 不显示行号（与下面配置冲突） lineNumbersInTable: true # 用表格布局行号（避免复制时带行号） noClasses: false # 使用CSS类（必须为false） style: github # 代码高亮主题（github、monokai、solarized-dark、dracula） tabWidth: 4 # 代码缩进空格数 goldmark: renderer: unsafe: true # 允许渲染原始HTML/LaTeX math: true # 支持数学公式 使用$$或者\\[\\]包围公式\n二、在GitHubPage部署网站 基本思路：建立两个仓库，一个网站仓库负责展示页面，另一个源仓库负责存储源码、更新内容并自动更新同步到网站仓库。\n1.建立网站仓库 在Github页面点击最上面的加号-New repository Repository name 填写 你的GitHub用户名.github.io，这样GitHub才会把它识别为网站仓库 选择Public 点击绿色的Create repository\n2.建立源仓库 同上建立仓库，随便命名，Public或Private都行 这里我命名为mywebsite\n3.GitHub 个人访问令牌 (Token) 生成\u0026amp;配置 点击右上角 头像 选择 Settings 左侧菜单选择 Developer settings 选择 Personal access tokens → Tokens (classic) 点击 Generate new token → Generate new token (classic) 设置 Token 信息： Token name：输入名称（如 mywebsite） Expiration：选择 No expiration（永不过期） 权限勾选： ✅ repo（全仓库权限） ✅ admin:repo_hook（仓库管理权限） 点击绿色按钮 Generate token 重要：立即复制生成的密钥并妥善保存（离开页面后将无法再次查看） 进入源仓库 点击settings 左侧Secrets and variables-Actions New repository secret 填写刚才的名称和密钥 Add sercet 4.配置workflow脚本 在本地网站根目录新建文件夹及文件.github/workflows/hugo.yaml 写入：\nname: github pages # 名字自取 on: push: branches: - main jobs: deploy: # 任务名自取 runs-on: ubuntu-latest\t# 在什么环境运行任务 steps: - uses: actions/checkout@v2\t# 引用actions/checkout这个action，与所在的github仓库同名 with: submodules: true # Fetch Hugo themes (true OR recursive) 获取submodule主题 fetch-depth: 0 # Fetch all history for .GitInfo and .Lastmod - name: Setup Hugo\t# 步骤名自取 uses: peaceiris/actions-hugo@v2\t# hugo官方提供的action，用于在任务环境中获取hugo with: hugo-version: \u0026#39;latest\u0026#39;\t# 获取最新版本的hugo extended: true - name: Build run: hugo --minify\t# 使用hugo构建静态网页 - name: Deploy uses: peaceiris/actions-gh-pages@v3\t# 一个自动发布github pages的action with: # github_token: ${{ secrets.GITHUB_TOKEN }} 该项适用于发布到源码相同repo的情况，不能用于发布到其他repo external_repository: Rook1eChan/Rook1eChan.github.io\t# 发布到哪个repo personal_token: ${{ secrets.MYWEBSITE2 }}\t# 发布到其他repo需要提供上面生成的personal access token publish_dir: ./public\t# 注意这里指的是要发布哪个文件夹的内容，而不是指发布到目的仓库的什么位置，因为hugo默认生成静态网页到public文件夹，所以这里发布public文件夹里的内容 publish_branch: main\t# 发布到哪个branch 只需要更改personal_token和external_repository\n5. SSH 密钥配置 检查是否已有 SSH Key\nWindows： 进入 C:\\Users\\你的用户名\\.ssh，查看是否存在 id_rsa（私钥）和 id_rsa.pub（公钥）文件。\n若有，说明已生成过 SSH Key，可直接使用。 若无，需重新生成。 Linux：\ncd ~/.ssh ls 检查是否存在 id_rsa 和 id_rsa.pub 文件。\n生成 SSH Key（若无） 运行以下命令（替换 xxx@xxx.com 为你的 GitHub 注册邮箱）：\nssh-keygen -t rsa -C \u0026#34;xxx@xxx.com\u0026#34; 连续按 3 次回车（使用默认路径，不设密码）。 生成的文件： id_rsa：私钥（切勿泄露）。 id_rsa.pub：公钥（需添加到 GitHub）。 将公钥添加到 GitHub 复制公钥内容（id_rsa.pub）： 登录 GitHub → 点击头像 → Settings → SSH and GPG Keys → New SSH Key。 测试 SSH 连接 在终端运行： ssh -T git@github.com 若显示 Hi 你的用户名!，说明配置成功。 之后clone或push时都选择SSH地址，而不是https地址。\n6.上传 本地网站根目录使用cmd，git@github.com:XXX/mywebsite.git改为源仓库地址：\ngit init git add . git remote add origin git@github.com:XXX/mywebsite.git git commit -m \u0026#34;Update\u0026#34; git push -u origin main 然后在源仓库的Action下，能看到正在Deploy，变绿色说明成功。此时网站仓库已自动更新了内容。\n进入网站仓库-settings-Pages-Build and deployment选择Deploy from a branch 刚才workflow脚本里写的是main，这里就选择main\n然后进入xxx.github.io，就可以看到你的网站了！🎉\n三、如何更新网站内容 不要在github和本地同时更改内容！不然会导致内容不同步，无法push。\n最好是一直都在本地更改，然后push到源仓库。\n1.本地更改后，比如新建了笔记，在网站根目录使用cmd： 不要复制注释！\ngit init //初始化git文件夹 git add . //添加变更内容 git remote add origin git@github.com:XXX/mywebsite.git //最后一项改为源仓库的地址，如果使用ssh连接的就复制ssh地址 git commit -m \u0026#34;new\u0026#34; //设置本次操作的名称，new可以随便改 git push -u origin main //把本地文件push到github上，增量更新 常见问题：\ngit push -u origin main的时候报错： error: src refspec master does not match any error: failed to push some refs to \u0026lsquo;github.com:Rook1eChan/mywebsite.git\u0026rsquo;\n使用git branch -a，查看branch的名称是不是main。如果是master，就把main改为master。\nTo github.com:Rook1eChan/mywebsite.git ! [rejected] main -\u0026gt; main (fetch first) error: failed to push some refs to \u0026lsquo;github.com:Rook1eChan/mywebsite.git\u0026rsquo; hint: Updates were rejected because the remote contains work that you do not\n说明你的GitHub和本地不同步。不建议强制合并，可以把GitHub整个repo clone到本地另一个文件，把变化的文件手动更改，再把新文件夹push上去。\n感谢GitHub、Hugo和Deekseek。\n","permalink":"https://Rook1eChan.github.io/posts/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%BB%BA%E7%AB%8Bgithub%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2hugopapermod/","summary":"\u003cp\u003egithub提供给每个用户一个网址，用户可以建立自己的静态网站。\u003c/p\u003e\n\u003ch2 id=\"一hugo\"\u003e一、Hugo\u003c/h2\u003e\n\u003cp\u003ehugo是一个快速搭建网站的工具，由go语言编写。\u003c/p\u003e\n\u003ch3 id=\"1安装hugo\"\u003e1.安装hugo\u003c/h3\u003e\n\u003cp\u003e到hugo的github标签页\u003ca href=\"https://github.com/gohugoio/hugo/tags\"\u003eTags · gohugoio/hugo\u003c/a\u003e选择一个版本，下载对应的安装包。比如\u003ccode\u003ehugo_extended_withdeploy_0.147.0_windows-amd64.zip\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e解压后，在根目录打开cmd，输入\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-cmd\" data-lang=\"cmd\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ehugo new site YourSiteName\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e为你的网站建立文件夹。\u003ccode\u003eYourSiteName\u003c/code\u003e更改为你的网站的名字。\n根目录会出现YourSiteName文件夹。\u003c/p\u003e\n\u003cp\u003e3.将根目录的hugo.exe复制到YourSiteName里。\n在YourSiteName文件夹里打开cmd，输入\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-cmd\" data-lang=\"cmd\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ehugo server -D\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e会返回如下信息：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-cmd\" data-lang=\"cmd\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                   \u003cspan class=\"p\"\u003e|\u003c/span\u003e EN\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e-------------------+-----\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  Pages            \u003cspan class=\"p\"\u003e|\u003c/span\u003e 11\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  Paginator pages  \u003cspan class=\"p\"\u003e|\u003c/span\u003e  0\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  Non-page files   \u003cspan class=\"p\"\u003e|\u003c/span\u003e  0\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  Static files     \u003cspan class=\"p\"\u003e|\u003c/span\u003e  0\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  Processed images \u003cspan class=\"p\"\u003e|\u003c/span\u003e  0\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  Aliases          \u003cspan class=\"p\"\u003e|\u003c/span\u003e  2\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  Cleaned          \u003cspan class=\"p\"\u003e|\u003c/span\u003e  0\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eBuilt in 79 ms\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eEnvironment: \u003cspan class=\"s2\"\u003e\u0026#34;development\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eServing pages from disk\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eRunning in Fast Render Mode. For full rebuilds on change: hugo server --disableFastRender\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eWeb Server is available at http://localhost:1313/ (bind address 127.0.0.1)\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ePress Ctrl+C to stop\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e在浏览器中输入\u003ccode\u003ehttp://localhost:1313/\u003c/code\u003e，显示Page Not Found，说明服务器正常运行，但是此时网站还没有页面。\u003c/p\u003e","title":"从0开始建立Github个人博客(hugo\u0026PaperMod)"},{"content":"原文：Neural-IR Models.. Neural IR(Information Retrieval) is a… | by Muhammad Hammad Khan | Medium\n译文：【翻译】一文详解神经信息检索领域的最新进展 - 知乎\n神经信息检索(Neural Information Retrieval, Neural IR)是信息检索领域的一个重要研究课题。自从谷歌在2018年发布BERT以来，它在11个NLP任务上获得了最先进的结果，一举改变了整个NLP领域的研究范式。2019年1月，Nogueira和Cho在MS MARCO Passage Ranking测试集上首次使用BERT。从那时起，人们开始研究神经信息检索的范式，也提出了许多基于BERT的文本排序方法。这些方法用于多阶段搜索架构的重排阶段(Re-Ranker)。如下图所示。\nFigure1 展示了一个简化的多阶段搜索结构。第一步：倒排索引（Inverted Index）+BM25得分进行排序，得到topK文档，这一步也叫候选项生成（Candidates Generation）。第二步，通过基于BERT的上下文排序模型来确定前N个文档的最终排序。\n神经重排模型(Neural re-ranking models)一般可以分为以下四种，如Figure2所示：\n基于表征(representation-focused) 基于交互(interaction-focused) 全交互（也被称作交叉编码器,）(all-to-all interaction(cross encoder) ) 迟交互(late interaction) 1.基于表征——双塔模型(Bi-encoder Models) 双塔模型将Query和Doc分别表征为密集的向量嵌入，用向量相似度分数来估计Q和D的相关性。在训练时需要正负样本进行对比学习，因为如果只给模型看正样本，它会偷懒——把所有向量都变成一样的，这样“相似度”永远最高。负样本强迫模型学会区分相关和不相关的内容。\n在将模型训练好后，doc和query的表征可以独立进行，不用像交叉编码器那样每次都要把Query和Doc拼在一起重新计算。\n1.1密集段落检索器(Dense passage retriever, DPR) 论文：Dense Passage Retrieval for Open-Domain Question Answering EMNLP 2020, Facebook Research Code: github.com/facebookresearch/DPR 讲解博客：【IR 论文】DPR — 最早提出使用嵌入向量来检索文档的模型_dpr模型-CSDN博客\nDPR是一个应用于问答领域的双塔模型，旨在最大限度地提高查询与相关文档的相似度，同时最小化与非相关文档的相似度。DPR是RAG中R的经典方案。\n正样本往往数据集已给定，而负样本比较难选择。为此，DPR提出了一种Batch内负采样的技术，从同一批次的其他样本中选择样本作为负样本。这种方法是有效且高效的。\n1.2最近邻负对比估计 (Approximate nearest neighbour Negative Contrastive Estimation, ANCE) 该论文证明了强负样本能够加速模型收敛，提升模型性能。负样本分为易区别的和不易区别的，显然不易区别（即强负样本）的对模型学习帮助更大。本文使用ANN寻找强负样本。\nDPR和ANCE的结果表明，双塔编码器不如交叉编码器有效，因为丧失了查询与文档的交互。但是开销更小，因为文档可以单独预先处理。\n2.迟交互模型（Late Interaction Models） 2.1Contextualized Late Interaction over BERT, ColBERT v2论文：ColBERTv2: Effective and Efficient Retrieval via Lightweight Late Interaction ColBERT\u0026amp;ColBERTv2讲解：ColBERT和ColBERTv2:兼具Bi-encoder和cross-encoder优势的多向量排序模型-CSDN博客\nColBERT引入延迟交互机制，相比交叉编码器效率提升了很多。\n简单来说，将Query和Doc进行分词，每个token生成一个嵌入向量。计算Query中每个词与Doc所有词的向量相似度。Query每个词取最高分，所有最高分加起来得到Doc的最终得分。\n独立编码： Query向量：[如何, 治疗, 感冒] Doc向量：[感冒, 病毒, 休息, 维生素C] 计算MaxSim： 治疗 → 与Doc所有词相似度最高的是休息（得分0.7）。 感冒 → 匹配Doc中的感冒（得分1.0）。 总分：0.7 + 1.0 = 1.7 ColBERT既像双塔模型，可以单独计算Doc的向量并存储；又像交叉编码器，实现token级别的交互。\n双塔模型将整句话表征为一个向量，而ColBERT将每个token都表征为一个向量，显然后者更细粒度，对语义理解更深。但是存储Doc的每个token的向量所需的空间比传统的倒排索引大得多。这种大内存占用的特点使 ColBERT 在大型语料库情形下不占优势。\nColBERTv2在ColBERT基础上使用更先进的训练方法来微调模型，并通过残差压缩方法大幅减少存储成本。\n3.基于知识蒸馏的神经重排模型 蒸馏的主要用途是减小模型大小并降低整体推理成本。\n论文：Improving efficient neural ranking models with cross-architecture knowledge distillation.\n该作者使用MSMARCO数据集对教师模型进行微调，用它对所有训练三元组打分，构建一个新的数据集。最后，学生模型在这个新构建的数据集上使用Margin MSE Loss进行训练，该损失函数优化了查询与非相关文本及相关文本分数之间的边距(Margin)。\n论文：Efficiently Teaching an Effective Dense Retriever with Balanced Topic Aware Sampling\nTAS-B方法，在训练时把Query按照话题进行聚簇，每个Batch内均匀采样Query，防止随机采样导致一个Batch内的话题都相似。\n就目前来看，RAG的检索远没有检索领域来的复杂，只是用了关键字检索，没有微调。\n","permalink":"https://Rook1eChan.github.io/posts/neural-ir-models/","summary":"\u003cp\u003e原文：\u003ca href=\"https://medium.com/@mhammadkhan/neural-re-ranking-models-c0a67278f626\"\u003eNeural-IR Models.. Neural IR(Information Retrieval) is a… | by Muhammad Hammad Khan | Medium\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e译文：\u003ca href=\"https://zhuanlan.zhihu.com/p/545429612\"\u003e【翻译】一文详解神经信息检索领域的最新进展 - 知乎\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e神经信息检索(Neural Information Retrieval, Neural IR)是信息检索领域的一个重要研究课题。自从谷歌在2018年发布BERT以来，它在11个NLP任务上获得了最先进的结果，一举改变了整个NLP领域的研究范式。2019年1月，Nogueira和Cho在MS MARCO Passage Ranking测试集上首次使用BERT。从那时起，人们开始研究神经信息检索的范式，也提出了许多基于BERT的文本排序方法。这些方法用于\u003cstrong\u003e多阶段搜索架构的重排阶段(Re-Ranker)\u003c/strong\u003e。如下图所示。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image\" loading=\"lazy\" src=\"/Neural-IR-Models-1.jpg\"\u003e\u003c/p\u003e\n\u003cp\u003eFigure1 展示了一个简化的多阶段搜索结构。第一步：倒排索引（Inverted Index）+BM25得分进行排序，得到topK文档，这一步也叫候选项生成（Candidates Generation）。第二步，通过基于BERT的上下文排序模型来确定前N个文档的最终排序。\u003c/p\u003e\n\u003cp\u003e神经重排模型(Neural re-ranking models)一般可以分为以下四种，如Figure2所示：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e基于表征(representation-focused)\u003c/li\u003e\n\u003cli\u003e基于交互(interaction-focused)\u003c/li\u003e\n\u003cli\u003e全交互（也被称作交叉编码器,）(all-to-all interaction(cross encoder) )\u003c/li\u003e\n\u003cli\u003e迟交互(late interaction)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg alt=\"image\" loading=\"lazy\" src=\"/Neural-IR-Models-2.jpg\"\u003e\u003c/p\u003e\n\u003ch2 id=\"1基于表征双塔模型bi-encoder-models\"\u003e1.基于表征——双塔模型(Bi-encoder Models)\u003c/h2\u003e\n\u003cp\u003e双塔模型将Query和Doc分别表征为密集的向量嵌入，用向量相似度分数来估计Q和D的相关性。在训练时\u003cstrong\u003e需要正负样本进行对比学习\u003c/strong\u003e，因为如果只给模型看正样本，它会偷懒——把所有向量都变成一样的，这样“相似度”永远最高。负样本强迫模型学会区分相关和不相关的内容。\u003c/p\u003e\n\u003cp\u003e在将模型训练好后，doc和query的表征可以独立进行，不用像交叉编码器那样每次都要把Query和Doc拼在一起重新计算。\u003c/p\u003e\n\u003ch3 id=\"11密集段落检索器dense-passage-retriever-dpr\"\u003e1.1密集段落检索器(Dense passage retriever, DPR)\u003c/h3\u003e\n\u003cblockquote\u003e\n\u003cp\u003e论文：\u003ca href=\"https://aclanthology.org/2020.emnlp-main.550\"\u003eDense Passage Retrieval for Open-Domain Question Answering\u003c/a\u003e\nEMNLP 2020, Facebook Research\nCode: \u003ca href=\"https://github.com/facebookresearch/DPR\"\u003egithub.com/facebookresearch/DPR\u003c/a\u003e\n讲解博客：\u003ca href=\"https://blog.csdn.net/qq_45668004/article/details/138256448\"\u003e【IR 论文】DPR — 最早提出使用嵌入向量来检索文档的模型_dpr模型-CSDN博客\u003c/a\u003e\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003eDPR是一个应用于问答领域的双塔模型，旨在最大限度地提高查询与相关文档的相似度，同时最小化与非相关文档的相似度。DPR是RAG中R的经典方案。\u003c/p\u003e\n\u003cp\u003e正样本往往数据集已给定，而负样本比较难选择。为此，DPR提出了一种Batch内负采样的技术，从同一批次的其他样本中选择样本作为负样本。这种方法是有效且高效的。\u003c/p\u003e\n\u003ch3 id=\"12最近邻负对比估计-approximate-nearest-neighbour-negative-contrastive-estimation-ance\"\u003e1.2最近邻负对比估计 (Approximate nearest neighbour Negative Contrastive Estimation, ANCE)\u003c/h3\u003e\n\u003cp\u003e该论文证明了强负样本能够加速模型收敛，提升模型性能。负样本分为易区别的和不易区别的，显然不易区别（即强负样本）的对模型学习帮助更大。本文使用ANN寻找强负样本。\u003c/p\u003e","title":"Neural-IR Models（博客）"}]